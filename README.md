# Mine Survivors ‚õèÔ∏èüíÄ

**Mine Survivors** to dynamiczna gra typu survival inspirowana tytu≈Çami takimi jak *Vampire Survivors*. Wciel siƒô w g√≥rnika eksplorujƒÖcego tajemnicze podziemne tunele, gdzie musisz przetrwaƒá niesko≈Ñczone fale przeciwnik√≥w, zdobywaƒá do≈õwiadczenie i ulepszaƒá swoje umiejƒôtno≈õci.

## üìö Spis tre≈õci

- [Opis projektu](#opis-projektu)
- [Cel projektu üéØ](#cel-projektu-)
- [Stack technologiczny üíª](#stack-technologiczny-)
- [Mechaniki rozgrywki üéÆ](#mechaniki-rozgrywki-)
- [Interfejs u≈ºytkownika (UI) üñ•Ô∏è](#interfejs-u≈ºytkownika-ui-)
- [Programowanie obiektowe w praktyce üèóÔ∏è](#programowanie-obiektowe-w-praktyce-)
- [Diagram UML architektury üìä](#diagram-uml-architektury-)
- [Instalacja i uruchomienie üöÄ](#instalacja-i-uruchomienie-)
- [Aktualizacje / Rozw√≥j üìà](#aktualizacje--rozw√≥j-)
- [Licencja üìÑ](#licencja-)

## Opis projektu

**Mine Survivors** to gra survival top-down 2D, w kt√≥rej gracz wciela siƒô w g√≥rnika eksplorujƒÖcego niebezpieczne podziemne kopalnie. Celem jest przetrwanie jak najd≈Çu≈ºej przeciwko falami wrog√≥w, zdobywanie do≈õwiadczenia, awansowanie na wy≈ºsze poziomy i odblokowywanie coraz potƒô≈ºniejszych ulepsze≈Ñ.

Gra ≈ÇƒÖczy klasycznƒÖ mechanikƒô survival z nowoczesnym systemem progresji postaci, oferujƒÖc intensywnƒÖ rozgrywkƒô z elementami strategii i zarzƒÖdzania zasobami.

## Cel projektu üéØ

- **Nauka programowania obiektowego** poprzez praktycznƒÖ implementacjƒô gry w C#
- **Demonstracja zaawansowanych zasad OOP** - dziedziczenie, polimorfizm, hermetyzacja, interfejsy
- **Rozw√≥j portfolio** i prezentacja umiejƒôtno≈õci w tworzeniu gier
- **Eksperymentowanie z silnikiem Godot 4.4.1** i jego mo≈ºliwo≈õciami C#
- **Praktyczne zastosowanie wzorc√≥w projektowych** (Singleton, Strategy, Observer)

## Stack technologiczny üíª

- **Silnik gry:** Godot Engine 4.4.1 (Mono)
- **Jƒôzyk programowania:** C# (.NET)
- **Architektura:** Programowanie obiektowe z wykorzystaniem interfejs√≥w i wzorc√≥w projektowych
- **System kontroli wersji:** Git / GitHub
- **Dokumentacja:** Markdown, komentarze w kodzie zgodne z XML Documentation
- **Grafika:** 2D top-down pixel art
- **Audio:** Efekty d≈∫wiƒôkowe 16-bit w stylu retro

## Mechaniki rozgrywki üéÆ

### Podstawowe mechaniki
- **Sterowanie 8-kierunkowe** - p≈Çynne poruszanie siƒô po mapie
- **Automatyczny system walki** - ≈Çuk automatycznie strzela do najbli≈ºszych wrog√≥w
- **System unik√≥w (dodge roll)** - szybkie unikanie atak√≥w z czasem nietykalno≈õci
- **Progresja postaci** - zdobywanie do≈õwiadczenia i awansowanie na wy≈ºsze poziomy

### System przeciwnik√≥w
- **Goblin** - szybki, agresywny przeciwnik poruszajƒÖcy siƒô bezpo≈õrednio do gracza
- **Hobgoblin** - taktyczny przeciwnik z atakiem "charge" w okre≈õlonym zasiƒôgu  
- **Golem** - wolny ale wytrzyma≈Çy przeciwnik z fazowym ruchem (ruch-odpoczynek)

### System ulepsze≈Ñ
Po ka≈ºdym awansie gracz wybiera jedno z trzech losowych ulepsze≈Ñ:
- **Prƒôdko≈õƒá** - zwiƒôksza szybko≈õƒá poruszania siƒô
- **Obra≈ºenia** - zwiƒôksza si≈Çƒô atak√≥w
- **Obrona** - zmniejsza otrzymywane obra≈ºenia
- **Zdrowie** - zwiƒôksza maksymalne punkty ≈ºycia

### Progresywna trudno≈õƒá
- **Dynamiczny spawning** - czƒôstotliwo≈õƒá pojawiania siƒô przeciwnik√≥w wzrasta z czasem
- **Ewolucja przeciwnik√≥w** - trudniejsi wrogowie pojawiajƒÖ siƒô w p√≥≈∫niejszych fazach gry
- **Poziomy trudno≈õci** - ≈Åatwy, Normalny, Trudny, Ekstremalny

## Interfejs u≈ºytkownika (UI) üñ•Ô∏è

### Menu systemy
- **Menu G≈Ç√≥wne** - Start, Opcje, Najlepsze Wyniki, Wyj≈õcie
- **Menu Opcji** - Konfiguracja audio, grafiki i trudno≈õci z zapisem do pliku
- **Menu Pauzy** - Wstrzymanie gry, dostƒôp do opcji, powr√≥t do menu
- **Menu Game Over** - Statystyki ko≈Ñcowe, ranking wynik√≥w, restart

### HUD (Heads-Up Display)
- **Pasek zdrowia** - wizualna reprezentacja aktualnych punkt√≥w ≈ºycia
- **Pasek do≈õwiadczenia** - postƒôp do nastƒôpnego poziomu z fioletowym motywem
- **Statystyki** - czas prze≈ºycia, liczba zabitych wrog√≥w, aktualny poziom
- **Menu Level Up** - wyb√≥r ulepsze≈Ñ po awansie

### System zapis√≥w
- **High Scores** - ranking 10 najlepszych wynik√≥w z szczeg√≥≈Çowymi statystykami
- **Ustawienia** - automatyczny zapis konfiguracji gracza
- **Postƒôp gry** - tracking statystyk i osiƒÖgniƒôƒá

## Programowanie obiektowe w praktyce üèóÔ∏è

Projekt **Mine Survivors** jest kompleksnƒÖ demonstracjƒÖ zaawansowanych technik programowania obiektowego w praktyce. Ka≈ºda z kluczowych zasad OOP zosta≈Ça ≈õwiadomie zastosowana i zaimplementowana.

### üîê Hermetyzacja (Encapsulation)

**Kontrolowany dostƒôp do danych** - wszystkie kluczowe w≈Ça≈õciwo≈õci sƒÖ chronione przed niepo≈ºƒÖdanƒÖ modyfikacjƒÖ:

```csharp
// Player.cs - Hermetyzacja statystyk gracza
[Export] public float BaseSpeed = 200f;      // Publiczne dla edytora
public float SpeedBonus { get; private set; } // Tylko odczyt z zewnƒÖtrz
public float TotalSpeed => BaseSpeed + SpeedBonus; // Obliczana w≈Ça≈õciwo≈õƒá

// Kontrolowany spos√≥b modyfikacji
public void AddSpeedBonus(float bonus) {
    SpeedBonus += bonus;
    GD.Print($"Speed bonus: +{bonus}. Total speed: {TotalSpeed}");
}
```

**Ukrywanie implementacji** - szczeg√≥≈Çy dzia≈Çania sƒÖ niewidoczne dla klient√≥w:

```csharp
// OptionsMenu.cs - Hermetyzacja logiki ustawie≈Ñ
private float _masterVolume = 1.0f;
private float _musicVolume = 0.8f;

private void ApplyAudioSettings() {
    // Kompleksowa logika zastosowania d≈∫wiƒôku ukryta w metodzie
    var masterBusIndex = AudioServer.GetBusIndex("Master");
    AudioServer.SetBusVolumeDb(masterBusIndex, LinearToDb(_masterVolume));
}
```

### üß¨ Dziedziczenie (Inheritance)

**Hierarchia klas z wsp√≥lnƒÖ funkcjonalno≈õciƒÖ** - klasy pochodne rozszerzajƒÖ mo≈ºliwo≈õci bazowych:

```csharp
// Enemy.cs - Klasa bazowa dla wszystkich przeciwnik√≥w
public partial class Enemy : CharacterBody2D, IDamageable, IAttack
{
    [Export] public float MaxHealth { get; set; } = 50f;
    [Export] public float MoveSpeed { get; set; } = 100f;
    
    // Metoda wirtualna - mo≈ºe byƒá nadpisana w klasach pochodnych
    protected virtual Vector2 CalculateMovement(Vector2 targetPosition) {
        Vector2 direction = (targetPosition - GlobalPosition).Normalized();
        return direction * MoveSpeed;
    }
}

// Goblin.cs - Konkretna implementacja przeciwnika
public partial class Goblin : Enemy
{
    protected override Vector2 CalculateMovement(Vector2 targetPosition) {
        Vector2 direction = (targetPosition - GlobalPosition).Normalized();
        float goblinSpeed = MoveSpeed * 1.2f; // 20% szybszy
        return direction * goblinSpeed;
    }
}
```

### üé≠ Polimorfizm (Polymorphism)

**Jedna interfejs, wiele implementacji** - r√≥≈ºne obiekty reagujƒÖ r√≥≈ºnie na te same operacje:

```csharp
// Weapon.cs - Abstrakcyjna klasa bazowa
public abstract partial class Weapon : Node2D, IAttack
{
    protected abstract bool ExecuteAttack(); // Ka≈ºda bro≈Ñ atakuje inaczej
}

// Bow.cs - Konkretna implementacja ≈Çuku
protected override bool ExecuteAttack() {
    var arrow = _arrowScene.Instantiate<Arrow>();
    arrow.Initialize(_arrowSpeed, Damage);
    GetTree().CurrentScene.AddChild(arrow);
    return true;
}

// U≈ºycie polimorfizmu - nie wiemy jakiej konkretnej broni u≈ºywamy
weapon.PerformAttack(target); // Ka≈ºda bro≈Ñ wykona sw√≥j unikalny atak
```

**Polimorficzne zachowanie przeciwnik√≥w**:

```csharp
// EnemySpawner.cs - R√≥≈ºne typy przeciwnik√≥w traktowane jednakowo
List<Enemy> enemies = new List<Enemy> {
    new Goblin(),    // Szybki i agresywny
    new Hobgoblin(), // Taktyczny z charge attack
    new Golem()      // Wolny ale wytrzyma≈Çy
};

// Ka≈ºdy przeciwnik porusza siƒô zgodnie ze swojƒÖ strategiƒÖ
foreach(Enemy enemy in enemies) {
    enemy.CalculateMovement(playerPosition); // Polimorfizm w akcji!
}
```

### üîå Interfejsy (Interfaces)

**Kontrakty behawioralne** - gwarantujƒÖ sp√≥jno≈õƒá implementacji:

```csharp
// IDamageable.cs - Wszystko co mo≈ºe otrzymaƒá obra≈ºenia
public interface IDamageable
{
    float MaxHealth { get; }
    float CurrentHealth { get; }
    bool IsAlive { get; }
    void TakeDamage(float damage);
}

// IAttack.cs - Wszystko co mo≈ºe atakowaƒá
public interface IAttack
{
    float Damage { get; }
    bool CanAttack { get; }
    float PerformAttack(IDamageable target);
}

// Praktyczne zastosowanie - Arrow wie jak zadaƒá obra≈ºenia ka≈ºdemu obiektowi
if (body is IDamageable damageable) {
    damageable.TakeDamage(_damage); // Polimorfizm przez interfejs
}
```

### üèóÔ∏è Wzorce projektowe (Design Patterns)

**Singleton Pattern** - jeden GameManager w ca≈Çej grze:

```csharp
// GameManager.cs - Centralny punkt zarzƒÖdzania
public partial class GameManager : Node2D
{
    public static GameManager Instance { get; private set; }
    
    public override void _Ready() {
        if (Instance != null) {
            QueueFree(); // Zabezpieczenie przed duplikatami
            return;
        }
        Instance = this;
    }
}
```

**Observer Pattern** - komunikacja przez sygna≈Çy:

```csharp
// Player.cs - Wydawca zdarze≈Ñ
[Signal] public delegate void LevelUpEventHandler(int newLevel);
[Signal] public delegate void HealthChangedEventHandler(float current, float max);

// HUD.cs - Subskrybent zdarze≈Ñ
private void ConnectToPlayer() {
    player.HealthChanged += OnPlayerHealthChanged;
    player.LevelUp += OnPlayerLevelUp;
}
```

### üß© Kompozycja (Composition)

**Sk≈Çadanie funkcjonalno≈õci** zamiast dziedziczenia:

```csharp
// Bow.cs u≈ºywa Arrow jako niezale≈ºny komponent
protected override bool ExecuteAttack() {
    var arrow = _arrowScene.Instantiate<Arrow>(); // Kompozycja
    arrow.Initialize(_arrowSpeed, Damage);
    // ≈Åuk "ma" strza≈Çƒô, ale nie "jest" strza≈ÇƒÖ
}

// LevelUpManager.cs u≈ºywa opcji ulepsze≈Ñ
public struct UpgradeOption {
    public string Name;
    public UpgradeType Type;
    public float Value;
}
// Manager "ma" opcje, ale nie dziedziczy po nich
```

### üìä Przyk≈Çady praktycznego zastosowania OOP

**1. System przeciwnik√≥w** - ka≈ºdy typ ma unikalne zachowanie:
- `Goblin` - prosty, szybki ruch
- `Hobgoblin` - z≈Ço≈ºona strategia z charge attack
- `Golem` - fazowy ruch z timerami Godot

**2. System broni** - r√≥≈ºne mechanizmy ataku:
- `Bow` + `Arrow` - atak dystansowy z pociskami
- Wsp√≥lny interfejs `IAttack` dla wszystkich broni

**3. System UI** - modularne menu:
- `MainMenu`, `OptionsMenu`, `PauseMenu` - ka≈ºde odpowiedzialne za swojƒÖ funkcjonalno≈õƒá
- Hermetyzacja logiki w ka≈ºdej klasie

## Diagram UML architektury üìä

Poni≈ºszy diagram przedstawia kompletnƒÖ architekturƒô projektu **Mine Survivors** z wykorzystaniem wszystkich zasad programowania obiektowego:

```mermaid
classDiagram
    %% ===== INTERFEJSY =====
    class IDamageable {
        <<interface>>
        +float MaxHealth
        +float CurrentHealth
        +bool IsAlive
        +TakeDamage(float damage)
    }
    
    class IAttack {
        <<interface>>
        +float Damage
        +bool CanAttack
        +PerformAttack(IDamageable target)
    }

    %% ===== PLAYER SYSTEM =====
    class Player {
        -float BaseSpeed
        -float SpeedBonus
        -float CurrentHealth
        -PlayerState _currentState
        +TotalSpeed
        +AddSpeedBonus(float bonus)
        +TakeDamage(float damage)
        +GainExperience(float amount)
        #CalculateMovement()
    }

    %% ===== ENEMY SYSTEM =====
    class Enemy {
        <<abstract>>
        +float MaxHealth
        +float MoveSpeed
        +float Damage
        -Player _player
        +TakeDamage(float damage)
        +PerformAttack(IDamageable target)
        #CalculateMovement(Vector2 target)*
    }

    class Goblin {
        +CalculateMovement(Vector2 target)
        %% Agresywny, 20% szybszy
    }

    class Hobgoblin {
        -bool _isCharging
        -float _chargeRange
        +CalculateMovement(Vector2 target)
        %% Charge attack w zasiƒôgu
    }

    class Golem {
        -bool _isMoving
        -Timer _moveTimer
        -Timer _restTimer
        +CalculateMovement(Vector2 target)
        %% Fazowy ruch: ruch-odpoczynek
    }

    %% ===== WEAPON SYSTEM =====
    class Weapon {
        <<abstract>>
        +float Damage
        +float Cooldown
        -float _cooldownTimer
        +PerformAttack(IDamageable target)
        #ExecuteAttack()*
    }

    class Bow {
        -float _arrowSpeed
        -PackedScene _arrowScene
        +ExecuteAttack()
        %% Tworzy Arrow i wystrzeliwuje
    }

    class Arrow {
        -float _speed
        -float _damage
        -float _travelledDistance
        +Initialize(float speed, float damage)
        +OnBodyEntered(Node2D body)
    }

    %% ===== MANAGER SYSTEM =====
    class GameManager {
        <<Singleton>>
        +static GameManager Instance
        -GameState _currentState
        -float _survivalTime
        -int _enemiesKilled
        +StartNewGame()
        +TogglePause()
        +RegisterEnemyKill()
        +AddExperience(float amount)
    }

    class LevelUpManager {
        -List~UpgradeOption~ _allUpgrades
        -Player _player
        +ShowLevelUpMenu(List options)
        +ApplyUpgradeToPlayer(UpgradeOption upgrade)
        +TriggerLevelUp()
    }

    class EnemySpawner {
        -PackedScene _goblinScene
        -PackedScene _hobgoblinScene
        -PackedScene _golemScene
        -Timer _spawnTimer
        +ChooseEnemyType()
        +SpawnEnemy(PackedScene scene, Vector2 pos)
    }

    class ScoreManager {
        <<Autoload>>
        -List~GameResult~ _scores
        +AddScore(float time, int kills, int level)
        +GetTopScores()
        +IsHighScore(int score)
    }

    %% ===== UI SYSTEM =====
    class MainMenu {
        -Button _startButton
        -Button _optionsButton
        +OnStartButtonPressed()
        +TransitionToScene(string path)
    }

    class GameOverMenu {
        -Label _scoreLabel
        -Button _restartButton
        +ShowGameOver(float time, int kills, float exp, int level)
        +CalculateScore()
    }

    class LevelUpMenu {
        -Button _option1Button
        -Button _option2Button
        -Button _option3Button
        +ShowUpgradeOptions(List options)
        +OnOptionSelected(int index)
    }

    class Hud {
        -ProgressBar _healthBar
        -ProgressBar _expBar
        -Label _timeLabel
        +UpdateSurvivalTime(float time)
        +OnPlayerHealthChanged(float current, float max)
    }

    %% ===== DATA CLASSES =====
    class GameResult {
        +string Timestamp
        +float SurvivalTime
        +int EnemiesKilled
        +int FinalScore
        +GetFormattedTime()
        +CalculateScore()
    }

    class UpgradeOption {
        <<struct>>
        +string Name
        +UpgradeType Type
        +float Value
        +string Description
    }

    %% ===== RELACJE DZIEDZICZENIA =====
    IDamageable <|.. Player : implements
    IDamageable <|.. Enemy : implements
    IAttack <|.. Player : implements
    IAttack <|.. Enemy : implements
    IAttack <|.. Weapon : implements

    Enemy <|-- Goblin : extends
    Enemy <|-- Hobgoblin : extends
    Enemy <|-- Golem : extends

    Weapon <|-- Bow : extends

    %% ===== RELACJE KOMPOZYCJI =====
    Player "1" --> "1" Bow : has
    Bow "1" --> "*" Arrow : creates
    
    GameManager "1" --> "1" Player : manages
    GameManager "1" --> "1" LevelUpManager : uses
    GameManager "1" --> "1" EnemySpawner : uses
    
    LevelUpManager "1" --> "*" UpgradeOption : uses
    EnemySpawner "1" --> "*" Enemy : spawns
    ScoreManager "1" --> "*" GameResult : stores
    
    Hud "1" --> "1" Player : observes
    LevelUpMenu "1" --> "1" LevelUpManager : communicates
```

### üîç Opis diagramu

**Interfejsy (<<interface>>):**
- `IDamageable` - wszystko co mo≈ºe otrzymaƒá obra≈ºenia
- `IAttack` - wszystko co mo≈ºe atakowaƒá

**Klasy abstrakcyjne (<<abstract>>):**
- `Enemy` - bazowa klasa dla wszystkich przeciwnik√≥w
- `Weapon` - bazowa klasa dla wszystkich broni

**Wzorce projektowe:**
- `GameManager` - **Singleton** zarzƒÖdzajƒÖcy grƒÖ
- `ScoreManager` - **Autoload** (Godot Singleton) dla wynik√≥w

**Relacje:**
- **Dziedziczenie** (`<|--`) - Goblin/Hobgoblin/Golem extends Enemy
- **Implementacja** (`<|..`) - Player/Enemy implements IDamageable
- **Kompozycja** (`-->`) - GameManager "ma" Player, Bow "tworzy" Arrow
- **Obserwacja** - HUD obserwuje Player przez sygna≈Çy

## Instalacja i uruchomienie üöÄ

### Wymagania systemowe
- **Godot Engine 4.4.1** z obs≈ÇugƒÖ C# (Mono)
- **.NET SDK** w wersji kompatybilnej z Godot
- **System operacyjny:** Windows 10+, macOS 10.15+, lub Linux

### Kroki instalacji

1. **Sklonuj repozytorium:**
   ```bash
   git clone https://github.com/twoj-username/mine-survivors.git
   cd mine-survivors
   ```

2. **Otw√≥rz projekt w Godot:**
   - Uruchom Godot Engine 4.4.1
   - Kliknij "Import" i wybierz plik `project.godot`
   - Upewnij siƒô, ≈ºe projekt rozpoznaje C# (powinien automatycznie zbuilowaƒá)

3. **Konfiguracja C#:**
   - Godot automatycznie utworzy pliki `.csproj`
   - Poczekaj na zako≈Ñczenie kompilacji

4. **Uruchom grƒô:**
   - Naci≈õnij F5 w Godot lub kliknij przycisk Play
   - Wybierz scenƒô g≈Ç√≥wnƒÖ je≈õli zostanie o to zapytany

### Struktura projektu
```
mine-survivors/
‚îú‚îÄ‚îÄ scenes/          # Sceny Godot (.tscn)
‚îÇ   ‚îú‚îÄ‚îÄ UI/         # Interfejsy u≈ºytkownika
‚îÇ   ‚îú‚îÄ‚îÄ enemies/    # Przeciwnicy
‚îÇ   ‚îî‚îÄ‚îÄ weapons/    # Bronie
‚îú‚îÄ‚îÄ scripts/        # Kod C#
‚îÇ   ‚îú‚îÄ‚îÄ player/     # System gracza
‚îÇ   ‚îú‚îÄ‚îÄ enemies/    # System przeciwnik√≥w  
‚îÇ   ‚îú‚îÄ‚îÄ weapons/    # System broni
‚îÇ   ‚îú‚îÄ‚îÄ managers/   # Managery gry
‚îÇ   ‚îú‚îÄ‚îÄ interfaces/ # Interfejsy
‚îÇ   ‚îî‚îÄ‚îÄ ui/         # Logika UI
‚îú‚îÄ‚îÄ assets/         # Grafiki, d≈∫wiƒôki
‚îî‚îÄ‚îÄ project.godot   # G≈Ç√≥wny plik projektu
```

## Aktualizacje / Rozw√≥j üìà

### ‚úÖ Zaimplementowane funkcjonalno≈õci

**Fundament projektu:**
- ‚úÖ Konfiguracja projektu Godot 4.4.1 z C#
- ‚úÖ Integracja z Git/GitHub
- ‚úÖ Struktura katalog√≥w i namespace'√≥w

**System gracza:**
- ‚úÖ Klasa `Player` z pe≈Çnym systemem ruchu
- ‚úÖ System zdrowia z hermetyzacjƒÖ
- ‚úÖ Dodge roll z nietykalno≈õci
- ‚úÖ State Machine (Normal, Rolling, Hurt, Dead)

**System przeciwnik√≥w:**
- ‚úÖ Abstrakcyjna klasa `Enemy` z polimorfizmem
- ‚úÖ `Goblin` - agresywny przeciwnik
- ‚úÖ `Hobgoblin` - taktyczny z charge attack
- ‚úÖ `Golem` - wolny z fazowym ruchem

**System broni:**
- ‚úÖ Abstrakcyjna klasa `Weapon`
- ‚úÖ `Bow` + `Arrow` - system pocisk√≥w
- ‚úÖ Polimorficzny system ataku

**Interfejsy u≈ºytkownika:**
- ‚úÖ `MainMenu` - menu g≈Ç√≥wne
- ‚úÖ `OptionsMenu` - pe≈Çna konfiguracja ustawie≈Ñ
- ‚úÖ `PauseMenu` - pauza w grze
- ‚úÖ `GameOverMenu` - statystyki ko≈Ñcowe
- ‚úÖ `LevelUpMenu` - wyb√≥r ulepsze≈Ñ
- ‚úÖ `HighScoresMenu` - ranking wynik√≥w
- ‚úÖ `HUD` - interfejs w grze

**Systemy zarzƒÖdzania:**
- ‚úÖ `GameManager` - Singleton zarzƒÖdzajƒÖcy grƒÖ
- ‚úÖ `LevelUpManager` - system awans√≥w
- ‚úÖ `EnemySpawner` - spawning przeciwnik√≥w
- ‚úÖ `ScoreManager` - ranking jako Autoload

**Interfejsy i architektura:**
- ‚úÖ `IDamageable` - system obra≈ºe≈Ñ
- ‚úÖ `IAttack` - system atak√≥w
- ‚úÖ Wzorce: Singleton, Observer, Strategy

### üöß W trakcie rozwoju

- üöß Dodatkowe typy broni (miecz, r√≥≈ºd≈ºka)
- üöß System ulepsze≈Ñ broni
- üöß Balansowanie rozgrywki

### ‚è≥ Planowane funkcjonalno≈õci

- ‚è≥ System power-up√≥w do zbierania
- ‚è≥ R√≥≈ºnorodne typy map/poziom√≥w
- ‚è≥ System osiƒÖgniƒôƒá
- ‚è≥ Tryb survival z falami
- ‚è≥ Dodatkowe efekty wizualne i d≈∫wiƒôkowe

### üéØ Cele d≈Çugoterminowe

- üéØ Pe≈Çna dokumentacja techniczna
- üéØ Diagram UML kompletnej architektury
- üéØ System mod√≥w i rozszerze≈Ñ
- üéØ Optymalizacja wydajno≈õci
- üéØ Publikacja na platformach dystrybucyjnych

## Licencja üìÑ

Projekt **Mine Survivors** jest udostƒôpniony na licencji MIT. Pe≈Çna tre≈õƒá licencji znajduje siƒô w pliku [LICENSE](LICENSE).

---

**Mine Survivors** to wiƒôcej ni≈º gra - to kompletna demonstracja programowania obiektowego w praktyce. Ka≈ºda linia kodu zosta≈Ça napisana z my≈õlƒÖ o czytelno≈õci, rozszerzalno≈õci i zgodno≈õci z najlepszymi praktykami OOP. 

≈öled≈∫ postƒôpy rozwoju na GitHub i do≈ÇƒÖcz do spo≈Çeczno≈õci! üöÄ‚õèÔ∏è